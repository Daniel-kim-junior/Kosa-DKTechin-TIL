### Annotation Processor란?

자바 컴파일러가 컴파일 과정에서 사용하는 기능
어노테이션 프로세서를 사용하여 소스 코드에서 선언된 어노테이션에 대한 정보를 추출하여
해당 정보를 바탕으로 코드를 생성하거나 분석할 수 있다.

```
어노테이션 프로세서는 자바 5부터 지원되는 기능으로, 소스 코드의 메타데이터 정보를 활용
하여 컴파일러나 런타임 환경에서 필요한 정보를 제공하는 역할

일반적으로는 컴파일 타임에 실행된다
```

*어노테이션 프로세서를 사용하여 할 수 있는 일

1. 코드 생성 - 어노테이션 프로세서를 사용하여 소소코드에 선언된 어노테이션을 정보를 바탕으로 코드를 생성할 수 있다. 예를 들어 JPA(@Entity) 어노테이션을 이용하여 Entity class를 생성하거나, Lombok(@Getter, @Setter) 어노테이션을 이용하여 Getter/Setter 메소드를 자동으로 생성하는 등의 작업이 가능함
2.  코드 검증 - 어노테이션 프로세서를 사용하여 코드에서 선언된 어노테이션 정보를 검증할 수 있다. 예를 들어 @NonNull 어노테이션을 사용하여 null 값을 허용하지 않는 변수에 null 값을 할당하면 컴파일 타임에 오류를 발생시킬 수 있다.
3. 리소스 생성 - 어노테이션 프로세서를 사용하여 리소스 파일을 생성할 수 있다. 예를 들어, 소스 코드에서 선언된 어노테이션을 사용하여 XML파일이나 프로퍼티 파일을 생성할 수 있다.

어노테이션 프로세서를 작성하기 위해서는 javax.annotation.processing 패키지의 AnnotationProcessor 인터페이스를 구현하고, META-INF/services/javax.annotation.processing.Processor 파일을 생성하여 구현한 AnnotationProcessor 클래스를 등록해주어야 한다.

어노테이션 프로세서는 자바의 메타프로그래밍 기술 중 하나이며, 코드를 생성하거나 분석하는 데 매우 유용한 기능이다.
---

### 프리미티브 타입과 레퍼런스 타입?

    primitive type

프리미티브란 원시적인 타입 즉 데이터 그 자체를 JVM의  Runtime Data Areas의 stack 영역에 그대로 저장하는 데이터 형식을 말합니다.

논리형(boolean) , 정수형(int, short, byte, long), 실수형(double, float), 문자형(char)

각각의 표현범위가 다름

    float은 4byte로 long의 8byte 보다 가용 용량은 적지만 더 많은 자료 범위를 표현할 수 있음 부동소수점 방식

-   메모리에 실제 값이 세팅된다.
-   JVM의 stack영역


    Reference type

JVM Heap 영역에 실제 값이 존재 Stack영역에 세팅된 heap영역의 주소값이 세팅

Heap 영역은 JVM의 Garbage Collector가 관리하는 영역


```
public void primitive_test() { 
    int i = 1; 
    double d 1.0; 
    primitiveType(i, d); 
    assertThat(i).isEqualTo(2); // false 
    assertThat(d).isEqualTo(2.0); // false 
}

public void primitiveType(int i, double d) { 
    i = 2; d = 2.0; 
}

```

**Java의 Call by Value로 인해 primitiveType(int i, double d)의
int i, double d 는 스택 영역(primitiveType)에 새로운 값이 복사되어 할당됨
기존 값과 별개이기 때문에 변경되지 않아 false로 판명

```
public void reference_test() {
    Animal animal = new Animal(); 
    animal.i = 1; 
    animal.d = 1.0; 
    referenceType(animal); 
    assertThat(animal.i).isEqualTo(2); // true       assertThat(animal.d).isEqualTo(2.0); // true 
    } 
    
    public void referenceType(Animal animal) { 
        animal.i = 2; animal.d = 2.0; 
    }
```


### 변수의 스코프와 라이프타임

일반 변수의 스코프는 중괄호 내에서만 영향을 미친다.
중괄호를 벗어난 즉 메소드나 클래스가 소멸 될 때 스코프를 벗어나게 되고 사라지게 된다.

```
public class JavaScope { 
    int i = 0; // instance varibles 
    public void scope() { // scope O } 
    
    public static void staticScope() { // scope X } }
```

static modifier는 클래스가 로드될때 메모리에 올라가기 때문에 객체가 생성되지 않아도 사용할 수 있다. 클래스가 힙 메모리에 인스턴스화 되는 순간 해당 필드가 생성되기 때문에 참조할 수 없다.

클래스 파일은 컴파일 시점 -> 클래스가 JVM에 로딩되는 시점
***(실행 시 클래스 메타 데이터와 함께 클래스 영역에 저장 Non - Heap 영역(MetaSpace))

Metaspace는 기존의 PermGen 영역보다 유연하게 메모리를 할당하여 클래스 메타데이터를 관리. 
Metaspace는 힙 영역 내부가 아니라, 네이티브 메모리 영역에서 클래스 메타데이터를 관리하며, 기존에는 고정 크기였던 PermGen 영역과 달리 필요한 만큼 메모리를 동적으로 할당

또한, Metaspace는 GC 작업도 더욱 효율적으로 처리할 수 있도록 개선 
예를 들어, PermGen 영역에서는 GC 작업을 위해 Full GC를 실행해야 했지만, Metaspace에서는 GC 작업을 위해 Young GC와 Old GC를 조합하여 더욱 효율적으로 메모리를 관리할 수 있게 되었습니다.


### Garbage Collection(GC)

JVM에 위치해 있는 GC는 자동으로 메모리를 관리해주는 기능이다.
GC는 사용되지 않는 객체를 자동으로 인식하여, 해당 객체가 사용하는 메모리를 해제.

개발자가 메모리에 대해 신경을 덜 쓸 수 있게 도와준다.

GC는 일반적으로 Heap영역에서 동작하지만 클래스 영역에서 클래스를 로드하거나 언로드 할 때도
Young GC와 Old GC로 나누어 효율적으로 메모리를 관리하는데
그 과정은 다음과 같다.
Young GC와 Old GC는 JVM에서 수행하는 Garbage Collection(GC) 작업 중에서 메모리 영역별로 구분하여 실행하는 방식

Young GC는 Eden 영역과 Survivor 영역1, 2에서 실행되는 GC 작업을 의미. 새로 생성된 객체는 Eden 영역에 할당되며, 

### Eden 영역이 가득 차면

객체 중에서 살아남은 객체는 Survivor 영역1로 이동됩니다. 그리고 다음번 Young GC가 실행될 때, Survivor 영역1에 남아있는 객체들 중에서 살아남은 객체는 Survivor 영역2로 이동된다. 
이후, Young GC가 다시 실행될 때는 Survivor 영역1에 남아있는 객체들과 Survivor 영역2에 남아있는 객체들 중에서 살아남은 객체들을 모두 Old 영역으로 이동시킨다.

Old GC는 Old 영역에서 실행되는 GC 작업을 의미하고 Old 영역은 Young GC가 여러번 수행되어도 살아남은 객체들이 이동하게 되는 메모리 영역이기 때문에 

Young GC보다는 큰 객체들이 저장되는 공간이다.

따라서 Old GC는 Young GC보다 더 드문 간격으로 실행되며, Old 영역에서 메모리 부족이 발생하거나, Full GC를 실행해야 할 때 실행된다.

Young GC와 Old GC는 메모리 영역별로 구분하여 실행함으로써, 메모리 부족을 더욱 효율적으로 처리할 수 있으며, GC 작업의 성능을 향상시킬 수 있다. (Divide)


GC의 과정은 두가지로 나눌 수 있는데
첫번째 단계는 더 이상 사용하지 않는 객체를 식별하는 것
두번째 단계는 해당 객체가 사용하고 있던 메모리를 해제하는 것

1.  Mark and Sweep 알고리즘

Java에서 가장 기본적으로 사용되는 GC 알고리즘은 Mark and Sweep 알고리즘입니다. 이 알고리즘은 다음과 같은 과정을 거칩니다.

-   먼저, 모든 객체를 순회하면서 사용되는 객체를 표시합니다. 이 과정을 "Mark" 단계라고 합니다.
-   Mark 단계가 끝나면, 표시되지 않은 객체(사용되지 않는 객체)를 Heap에서 제거합니다. 이 과정을 "Sweep" 단계라고 합니다.

이 과정에서 GC는 메모리에서 불필요한 객체를 제거하고, 메모리를 효율적으로 관리하여 애플리케이션의 성능을 최적화합니다.

2.  압축(Compaction) 알고리즘

Mark and Sweep 알고리즘 외에도, Java에서는 압축(Compaction) 알고리즘도 사용됩니다. 이 알고리즘은 Heap에서 사용되지 않는 객체를 제거하는 대신, 사용되는 객체를 한 곳으로 모아서 메모리 공간을 확보하는 방법입니다. 이렇게 하면 GC가 빈번히 발생할 때마다 Heap 내부에 메모리 조각이 생기는 것을 방지할 수 있습니다.

압축 알고리즘은 Mark and Sweep 알고리즘에 비해 더 복잡하고 성능이 좋지 않은 경우가 있지만, Heap 내부에서 메모리 조각이 발생하는 것을 방지하므로 애플리케이션의 성능을 개선하는 데 도움을 줄 수 있습니다.


---

### 에러 처리

    try catch finally - 적극적 예외 처리
    runTime Error를 의도적인 프로그램의 한 부분으로 바꿀 수 있다.
    
    throw throws - 에러를 상위 스택으로 책임을 위임하는 소극적 예외 처리 마지막까지 던지게 된다면 JVM이 처리하게 된다
    
    
    Exception을 조상으로 가지고 있는 메소드들은 반드시 예외를 처리해 주어야 한다.
    RunTimeException을 조상으로 가지고 있는 메소드들은 예외를 선택적으로 처리할 수 있다.


---

### interface vs Abstract class
    - 둘다 추상화(다형성)를 위한 도구
    - Java8에서 부터 Interface는 default method와 static Method를 가지게 되었다.(구현 가능)
    - interface는 상수만 사용할 수 있다 (public static final - 자동으로 붙여준다.)
    - interface는 모든 추상 메서드를 public으로 강제한다.
    - 반면에 Abstract는 다양한 접근제어자를 사용 가능하다.
    - Abstract는 생성자를 가질 수 있다.
    - interface는 다중 상속이 가능하다 상속 받을 때는 extends 키워드를 사용한다
    
---

### 상속
    - 상속 주의점!
        - 접근제어자를 조상보다 더 넓거나 같은 접근제어자만 사용 가능하다.
        - class 상속은 Override를 강제하지 않지만 interface는 Override를 강제한다.
        - 부모 변수에 담은 자식 인스턴스는 부모에 정의되어 있지 않은 메소드를 사용해야 할 때
            명시적 형변환이 필요하다
