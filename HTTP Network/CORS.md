# Cross Origin Resource Sharing

한마디로 브라우저의 리소스 관리 정의

한국어로 직역하면 교차 출처 리소스 공유이다.

여기서 교차출처는 "다른 출처"를 의미하는 것인데

여기서 말하는 출처(Origin)란 무엇일까?

### 출처(Origin)이란?

서버의 위치를 의미하는 https://google.com과 같은 URL들은 마치 하나의 문자열 같아 보여도,

사실은 여러개의 구성요소로 이루어져 있다.

protocol:// host / path ? Query String #Fragment

이때 출처는 Protocol과 Host, 그리고 포트 번호까지 모두 합친 것을 의미한다.

즉 서버의 위치를 찾아가기 위해 필요한 가장 기본적인 것들을 합쳐 놓은 것이다.

또한 출처 내의 포트 번호는 생략이 가능한데, 이는 각 웹에서 사용하는 HTTP, HTTPS 프로토콜의 기본 포트번호가 정해져 있기 때문이다.

**결국 출처는 프로토콜 + 호스트 + 포트번호인 것이다!!!

### SOP(Same-Origin-Policy)

웹 생태계에는 다른 출처로의 리소스를 제한하는 것과 관련된 두 가지 정책이 존재한다.

한 가지는 우리의 탐구영역인 CORS, 또 한가지는 SOP(Same-Origin Policy)이다.

SOP는 2011년 처음 등장한 보안 정책으로 말 그대로 "같은 출처에서만 리소스를 공유할 수 있다"
라는 규칙을 가진 정책이다.

그러나 웹이라는 오픈스페이스 환경에서 다른 출처에 있는 리소스를 가져와서 사용하는 일은 매우 흔한 일이라

무작정 막을 수도 없느 노릇이니 몇 가지 예외 조항을 두고 이 조항에 해당하는 리소스 요청은 출처가 다르더라도 허용하기로 했는데, 그 중 하나가 "CORS 정책을 지킨 리소스 요청" 이다.

우리가 다른 출처로 리소스를 요청한다면 SOP 정책을 위반한 것이 되고, 거기다가 SOP의 예외조항인 CORS 정책
까지 지키지 않는다면 아예 다른 출처의 리소스를 사용할 수 없게 되는 것이다.

즉 이렇게 다른 출처의 리소스를 사용하는 것을 제한하는 행위는 하나의 정책만으로 결정된 사항이 아니라는 의미가 되며, SOP에서 정의된 예외 조항과 CORS를 사용할 수 있는 케이스들이 맞물리지 않을 경우에는 아예 리소스 요청을 할 수 없는 케이스도 존재할 수 있다.

그렇다면 근본적인 의문으로 왜? 이런 정책을 설정한 것일까?

하지만 이렇게 출처가 다른 두 개의 어플리케이션이 마음대로 소통할 수 있는 환경은 꽤나 위험한 환경이다.

애초에 클라이언트 어플리케이션, 특히나 웹에서 돌아가는 클라이언트 어플리케이션은 사용자의 공격에 너무나도 취약한 아이라는 사실이다.

당장 브라우저 개발자 도구만 열어도 DOM이 어떻게 작성되었는지, 어떤 서버와 통신하는지, 리소스의 출처는 어디인지와 같은 정보들을 아무런 제재없이 열람할 수 있지 않나?

최근에는 자바스크립트 소스 코드를 난독화해서 읽기 어렵다고 하지만, 난독화는 어디까지나 난독화
암호화가 아니다.

그리고 아무리 난독화되어있다고 해도 사람이 바로 이해할 수 없는 정도도 아닌데다가, 소스 코드를 직접 볼 수 있다는 것 자체가 보안적으로 상당히 취약한 부분이다. 심지어 아직까지도 소스 코드의 난독화가 안되어 개발자 도구만 열면 <script> 태그 안에 날 것 그대로의 소스 코드가 떡하니 노출되어 있는 사이트도 많다.

이러한 상황 속에서 다른 출처의 어플리케이션이 서로 통신하는 것에 대해 아무런 제약도 존재하지 않는다면, 악의를 가진 사용자가 소스 코드를 구경한 후 CSRF(Cross-Site Request Forgery)나 XSS(Cross-Site Scripting)와 같은 방법을 사용하여 어플리케이션에서 코드가 실행된 것처럼 꾸며 사용자의 정보를 탈취하기가 너무 쉬워진다.

### 같은 출처와 다른 출처의 구분

출처가 같다고 판단하는 기준은 뭘까?

바로 Schema, Host, Port 이 3가지만 동일하면 된다.

https://naver.com:80라는 출처를 예로 들면 https:// 이라는 스키마에 naver.com 호스트를 가지고
:80번 포트를 사용하고 있다는 것이 같으면 같은 출처로 인정된다.

만약 https://naver.com:8080 같은 케이스는 만약 출처에 https://naver.com:80처럼 포트번호가 명시되어 있었다면 명백하게 다른 출처이지만 포트번호가 포함되지 않았다면
각 브라우저들의 독자적인 출처 비교 로직을 따라가게 된다.

여기서 중요한건 브라우저에 구현되어 있는 스펙이라는 것이다.
서버에 같은 출처의 요청만 받겠다는 스펙이 구현되어 있지 않으면
브라우저는 서버에게 정상적으로 요청을 보내고 정상적으로 서버는 응답한다.
후에 request 분석을 통해 Cors 정책을 위반했다면 그 응답을 버린다.

그렇기 때문에 브라우저를 통하지 않는 서버간 통신은 이 정책이 적용되지 않는다.
또 CORS 정책을 위반하는 리소스 요청 때문에 에러가 발생했다고 해도 서버 쪽 로그에는 정상적으로 응답했다는 로그만 남기 때문에, CORS가 돌아가는 방식을 정확히 모르면 에러 트레이싱에 난항을 겪을수도...?






