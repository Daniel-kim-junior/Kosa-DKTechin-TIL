
## OSI 7계층 (각 계층은 바로 위 계층을 식별하는 Flag 탑재)

	1. 물리 계층 - 데이터 단위(Bit) , 전기적 기계적 계층
	2. 데이터 링크 계층 - 데이터 단위(Frame), Ethernet 3계층에게 논리적 통로 제공, 신뢰성 있는 정보 교환
	3. 네트워크 계층 - 데이터 단위(Packet), IP, IPX 등... 각 기기의 접속과 설정 유지 해지 등의 기능 제공 (데이터 전송과 교환 기능 제공)
	4. 전송 계층 - 데이터 단위(Message), Port를 통해 프로세스간 논리적 통로 제공, 하위 계층의 각종 통신망의 차이를 보완하고, 상위층과 명확한 정보전송 보장 계층 (TCP, UDP, SPX)
	5. 세션 계층 - 대화 세션, 클라이언트와 서버간 연결과 동기 제공
	6. 표현 계층 - 응용계층 엔티티간 데이터 교환을 위해 Syntax 직렬화 및 역직렬화 Format, 압축, 해독, 변환등을 관장하는 계층 
	7. 응용 계층 - 응용 프로세스가 OSI를 Access하게 해주는 계층, 파일 전송, 터미널, 전자메일 등의 UI를 제공하는 계층 (SMTP, FTP, HTTP)


## Network Class

	1. A Class [0.0.0.0 ~ 126.255.255.255] : 하나의 네트워크에 여러명의 Host가 존재할 때 좋음 
	2. B Class [128.0.0.0 ~ 191.255.255.255] : 중형 구조
	3. C Class [192.0.0.0 ~ 223.255.255.255] : 소형 구조
	4. D class [224.0.0.0 ~ 239.255.255.255] : 멀티 캐스트를 위해 정의된 클래스
	5. E class [240.0.0.0 ~ 247.255.255.255] : 향후 사용을 위한 클래스


## 각종 Network 명령어

#Ping - 원격 호스트에게 도달하는 지, 패킷 분실, 응답 시간에 대한 정보 제공
#Netstat - 케이블/인터페이스 양호 상태, 시스템 I/O 트래픽율, 라우팅 테이블, Collision rate 계산
#ipconfig, #ifconfig - Windows OS, Linux의 IP어드레스 정보 확인


## Web Application Server와 Web Server의 차이

	Web Application Server - Tomcat, JBoss, Jetty 등
	동적인 처리 즉 client의 Request에 따라 Response가 달라질 수 있는 가능성을 가진 부분을 처리하는 
	서버 (DB Server와 Web Server 중간에 보통 위치) “웹 컨테이너(Web Container)” 혹은 “서블릿 컨테이너(Servlet Container)”라고도 불린다. 여러개의 트랜잭션 관리 기능 (분산 트랜잭션)

	Web Server - Nginx, Apache 등
	정적인 처리 즉 client의 Request에 상관없이 항상 같은 Response를 제공해주는 랜딩 페이지, 고정 이미지 등을 WAS를 패싱하여 제공해주어 WAS의 부담을 줄여준다 또 LoadBalancing 기능을 가지고 있어 다중화 되어 있는 서비스에 알고리즘을 적용하여 부하 분산을 통해 WAS의 부담을 이중으로 줄여준다.
	

----


## HTTP란?

- 80번 포트를 사용하는 응용 계층 프로토콜
	인터넷에서 데이터를 주고 받을 수 있는 프로토콜
	HTTP/1.1, HTTp/2.0 등이 있다.

	구성요소 (Request)
	- 요청 라인 : Method 방식, 요청 URL
	- 요청 헤더 : 인코딩 방식
	- 요청 본체 : Request Body

	구성요소(Response)
	- 상태 라인 : 상태 코드와 프로토콜 버전
	- 헤더 : 인코딩 방식, 서버 정보
	- Response Body

```
상태 코드
2xx : Response.OK
3xx : 리퀘스트 완료를 위해 추가 동작이 필요함.
4xx : Client Error
5xx : Server Error
```


### Http Method
	1. Get : 단순히 데이터를 요청하는 Method (멱등성을 보장하고 안전한 메소드)
	2. Post : 데이터를 등록하는 Method(멱등성을 보장하지 않고 안전하지 않은 메소드) 
	3. Put : 데이터를 수정하는 Method(멱등성을 보장하지만 안전하지 않은 메소드)
	4. PATCH : 데이터를 부분적으로 수정할 수 있는 Method(멱등성이 항상 보장됨을 장담할 수 없음, 안전하지 않은 메소드)
	5. Delete : 데이터를 삭제하는 Method(멱등성을 보장하지만 안전하지 않은 메소드)

### 멱등성이란?

- 서버에 동시에 요청하는 경우 서버 상태가 동일하여 항상 같은 값을 Response하는 것을 보장하는 성질
- ex) 같은 Request put을 여러번 호출해도 항상 동일한 값이 Response됨을 보장하기 때문에 멱등함
- PATCH는 부분 수정이 가능하기 때문에 멱등성이 보장되지 않는다.

### 안전함이란?

- 서버의 상태를 변화시키지 않는 Method, #Get #Head 등...

  
### 캐시 가능성
- 브라우저 또한 소프트웨어이고 캐싱이 가능하기 때문에 Response를 캐싱할 수 있다.
- 값을 변화시키지 않는 Get이나 Head 정도만 캐시 가능성이 보장 된다.



-----

# CSR vs SSR

## CSR(Client Side Rendering)
- 서버가 요청을 받았을 때 빈 HTML과 HTML에 종속되어 있는 JavaScript 코드를 클라이언트에게 아무런 작업없이 보낸다.
- 클라이언트는 요청을 받고 난 후 HTML을 Javascript를 통해 렌더링한다.
- 그렇기 때문에 초기 요청 시간이 Delay되며 UX에 부담을 주게 된다.
- 첫 로딩이 길지만 이미 모든 HTML을 클라이언트 사이드에서 렌더링 했기 때문에 

----

*이럴 때 쓰자*

- SEO에 관심이 없을 때
- 네트워크가 빠를 때 (한번에 첫 리소스를 다 받아오기 때문에)
- 웹 어플리케이션의 상호작용이 많을 때 (현재 CSR은 컴포넌트 별로 비동기적으로 데이터를 불러오는 것이 가능함)
- 서버의 성증이 좋지 않을 때
- 데이터 양이 많을 때 (로딩 창을 띄울 수 있는 장점)
- 메인 스크립트가 가벼울 때 (초기 로딩이 빨라서)
----

## SSR(Server Side Rendering)

서버에서 HTML을 완성시켜 클라이언트에게 보내는 방식
HTML이 먼저 도착하고 이후에 JS가 도착하기 때문에 그 사이에서는 상호작용이 불가하다
초기 화면 로드는 빠르긴하다.
서버에서 로드를 하기 때문에 서버에 부하가 많이가는 편이다.


----
*이럴 때 쓰자*

- 네트워크가 느릴 때 (페이지를 나누어 가져올 수 있다)
- SEO가 필요할 때 (크롤러는 JS를 실행 시키지 않기 때문에)
- 최초 로딩이 빠른 페이지를 구성할 때
- 메인 스크립트가 매우 크고 로딩이 매우 느릴때 (한번의 요청에 모든 데이터가?)
- 웹 사이트가 상호작용이 필요없을 때




