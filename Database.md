
## DataBase

- ***Database란?
	한 조직의 여러 응용 시스템들이 공용(Shared)하기 위해
	통합, 저장, 운영데이터 집합
	컴퓨터 시스템과 무관하게 데이터의 구조적 집합을 의미한다(종이, 장부 등도 가능)
	논리적, 물리적 데이터의 집합이라고 생각한다.
----

### DBMS(Database Management System)

- DB 관리를 위한 컴퓨터 시스템
- 전사적 정보 관리
- 관련된 데이터의 Set
- 데이터에 접근하는 프로그램 Set
- 효율적이고 편한 사용을 위한 환경


**무수히 많은 Transaction의 향연

---

### Transaction이란??

	트랜잭션이란 - 데이터베이스의 상태를 변화시키기 위해 수행하는 작업 단위를 뜻한다.
	데이터 베이스의 상태를 변화시키는 것은 무엇을 의미하는가?
	바로 질의어 
		SELECT, Update, Insert, Delete 등을 통해 데이터베이스에 접근하는 것이다.

**착각하기 쉬운점은 작업의 단위는 하나의 질의 문장이 아니라는 점!!!

```
작업단위는 많은 질의어 명령문들을 개발자가 정하는 기준에 따라 정하는 것을 의미한다!

예를들어 게시판에서
사용자가 게시글을 작성하고, 작성하기 버튼을 상호작용하고 업데이트 된 게시판을 보게 되었을때

데이터베이스에서 일어나는 일은
Post Request가 가고 서버 DB에 게시글이 저장되고 다시 클라이언트로 Response되어 Redirection(Select)이 일어나서 Update가 된다.

여기서 일어나는 작업은 Insert와 Select가 함께 일어난다

이런 일련의 과정 설계를 Transaction이라고 한다.

트랜잭션 설계를 처음부터 잘해야 효율성 있는 시스템을 개발할 수 있다.

```


---

## Transaction의 4가지 특징

*ACID를 잘 지키자*

*Atomicity(원자성)* - **원자성은 Transaction이 DB에 전부 반영되거나 전부 반영되지 않아야 한다는 특성이다. 트랜잭션은 사람이 설계한 논리적인 작업 단위기 때문에 일처리가 작업단위 별로 일어나야한다.

*Consistency(일관성) - **작업처리 결과가 항상 일관성이 있어야 한다는 것 트랜잭션이 일어날 때 다른 트랜잭션으로 인해 DB가 변경되더라도 트랜잭션이 일어났을 당시에 DB를 참조하여 진행해야 한다. 이렇게 함으로써 사용자가 일관된 데이터를 볼 수 있게 만들어야 한다.

*Isolation(독립성) - **둘 이상의 트랜잭션이 일어나고 있을 때 서로 간섭하거나 침범해서는 안되는 성질이다. 트랜잭션이 끝날때까지 다른 트랜잭션이 참조할 수 없다

*Durability(지속성) - **성공적인 트랜잭션이 일어나면 트랜잭션의 결과가 영구적으로 시스템에 반영되어야 하는 성질이다.

---
## RollBack과 Commit

***Commit - 트랜잭션이 성공적으로 끝났을 때, 데이터베이스가 일관성있는 상태에 있을 때 성공적인 트랜잭션 종료 연산이다.

***RollBack - 하나의 트랜잭션의 원자성이 깨지거나 트랜잭션 처리가 비정상적으로 종료 되었을때
이전 Commit 이후의 Transaction 처리 단위대로 RollBack을 진행 할 수 있다.

#Commit 이전의 결과로는 되돌아갈 수 없는 것을 주의하자

---
## RDBMS(MySQL)

	MySQL의 장점 중 하나는 여러개의 스토리지 엔진을 지원한다는 것이다.

	스토리지 엔진이란?
	DB에서 데이터를 어떤 방식으로 저장하고 접근할 것인지에 대한 기능을 제공하는 소프트웨어
	각 스토리지 엔진의 특성에 따라 속도와 안정성 그리고 기능 제공의 차이점이 발생한다.

**1.MyISAM

**MySQL 기본 스토리지 엔진 - 데이터 저장에 제한이 없고 매우 효율적 방식
    Full-Text 인덱스를 지원하며 특정 인덱스에 대한 메모리 캐쉬 지원
    Transaction을 미지원
    그러나 Table Lock을 지원하여 잦은 변경 및 삭제에 대해서는 좋은 성능이 나오지 못하나
    데드락을 예방할 수 있음
    테이블 작업시 특정 행을 수정하려고 하면 테이블 전체에 락이 걸려 다른 스레드가 작업하지 못한다. (Table Level Lock)
    Transaction을 미지원하기 때문에 작업 도중 문제가 생겨도 DB안에 데이터가 들어가기 때문에 주의해야함
    Select가 많거나 중요하지 않는 데이터를 다루는 Logging 작업 저장에 어울릴듯 하다.


**2. InnoDB
	ACID Transaction을 지원한다. MyISAM보다 데이터 저장비율이 낮고, 데이터 로드 속도가 느리다.
	(아무래도 Transaction을 지원하다 보니 데이터 검증을 위한 Cost가 증가하는 듯)
	특정 데이터와 인덱스에 대해 메모리 캐쉬 지원함
	데이터 압축은 불가능하며 자동 에러 복구 기능을 제공
	Table Lock이 아닌 ROW 레벨의 Lock을 지원
	테이블 작업시 테이블 전체가 아닌 해당 행만 잠기게 되며 나머지 부분은 수정 가능하여
	Insert, update, delete에 대한 속도가 빠르다.
	주로 데이터 입력 및 수정이 빈번한 높은 퍼포먼스를 요구하는 시스템에 적합하다.

**3. Cluster
	Transaction을 지원하고 모든 데이터와 인덱스가 메모리에 존재
	그러므로 속도가 매우 빠르다. PK 사용 시 최상의 속도를 나타냄

**4. Archive
	MySQL 5.0이후의 엔진 자동적으로 데이터 압축 지원(InnoDB와 다른 점) 다른 엔진에 비해 80% 저장 공간 절약 효과를 가지고 있다고 한다. 빠른 데이터 로드 속도를 자랑하지만
	Select와 Insert만 가능하다.

**5. Federated
	MySQL 5.0부터 새롭게 도입된 엔진으로 물리적 데이터베이스에 대한 논리적 데이터베이스를 생성하여 원격 데이터를 컨트롤 할 수 있다. 실행속도는 네트워크 요소에 따라 좌우되면 테이블 정의를 통한 SSL 보안 처리를 한다. 분산 데이터베이스 환경에 사용한다

---
## DB 용어 (카디널리티, 스키마, 릴레이션, 어트리뷰트, 튜플, 도메인, 차수)

*1. 릴레이션(엔티티, 테이블)
```
릴레이션이란 관계형 데이터베이스에서 정보를 구분하여 저장하는 기본 단위이다.
ERD(Entity Relationship Diagram)의 가장 큰 구성요소 중 하나다.

특징:
	- 한 릴레이션에는 똑같은 튜플(Tuple)이 포함될 수 없다. (Row의 중복 불가)
	- 한 릴레이션에 포함된 튜플 사이에는 순서가 없다.
	- 튜플들의 삭제, 삽입 등의 작업으로 릴레이션은 시간에 따라 변한다.(Index 또한 변함)
	- 릴레이션 스키마를 구성하는 속성들간의 순서는 중요하지 않다.
	- 속성의 유일한 식별을 위해 속성의 명칭은 유일해야한다. 속성을 구성하는 값은 동일한 값이 있을 수 있다.
	- 릴레이션을 구성하는 튜플을 유일하게 식별하기 위해 속성들의 부분집합을 키(Key)로 설정한다.
	- 속성의 값은 논리적으로 더 이상 쪼갤 수 없는 원자 값만을 저장한다.

```

*2.속성(attribute)
```
하나의 릴레이션은 현실세계의 어떤 개체(entity)를 표현하고 저장한다.

엔티티는 논리적 혹은 물리적 개념 둘다 가능하다.

속성은 내가 정의내리고 싶은 Entity의 특성 항목이다.
```

*3.차수(degree)*
```
한 릴레이션 안에 있는 속성 수를 차수 라고 한다.

엔티티의 최소 차수는 1이다.

그렇기 때문에 모든 엔티티(릴레이션)은 적어도 하나 이상의 속성을 가지고 있어야 한다.
```

*4.튜플(Tuple)
```
테이블의 각 행을 레코드라고 한다.
레코드를 튜플이라고 부른다.
```

*5.카디날리티(Cardinality)*
```
카디날리티는 릴레이션 튜플의 개수이다.

그래서 아직 삽입되지 않은
릴레이션(엔티티, 테이블)
은 카디날리티가 0일 수 있다.

카디날리티는 변동성을 가진다.
```

*6. 도메인(Domain)*
```
도메인은 릴레이션에 포함된 속성들이 각각 가질 수 있는 값들의 집합이다.

예를들어 집이라는 릴레이션에
거래종류라는 속성이 있따고 하자
거래종류에는 (전세, 월세, 매매)가 있다. 이 집합을 X라고 이름 붙이자

X라는 도메인만 거래종류 속성이 가질 수 있다.

하나의 도메인을 여러 속성에서 공유할 수는 있고 속성의 이름과 도메인의 이름은 서로 동일하지 않아도 된다.

```

*7.스키마*
```
스키마는 데이터베이스의 구조와 제약조건에 관한 전반적인 명세를 기술한 메타데이터의 집합이다.

엔티티와 속성 관계 및 데이터 조작 시 데이터 값들이 갖는 제약 조건 전반에 대한 정의다.

스키마는 세개로 나누어진다.

1. 외부 스키마 : 외부에서 현실세계에 가까운 엔티티들의 나열이다.
2. 개념 스키마 : 개발자가 정의 내리는 속성에 대한 정의가 있다.
3. 내부 스키마 : 속성들의 더 세부적인(DB 친화적인 index 등...) 정보들을 담고 있는 스키마이다. 

```


***논리 모델과 물리모델
Entity  ------ Table
속성 -------- 컬럼
  관계, 릴레이션
키 그룹 ----- Index


## Primary key

```
릴레이션에서 튜플을 구분하기 위하여 사용하는 기본 키

하나의 속성, 여러개의 속성을 묶은 복합키가 가능하다.
관리자에 의해 릴레이션 생성시 정의되며, 자동으로 Index가 생성된다.

동일한 PK는 존재할 수 없다.

Candidate Key(후보 키) - 튜플을 식별 할 수 있는 최소한의 속성 집합
PK가 될 수 있는 후보들
유일성과 최소성을 충족시킨다면

Alternative Key(대체 키) - 후보 키 중 기본 키가 아닌 속성
```

### Foreign Key
```
다른 릴레이션의 기본 키를 참조하는 키

다른 릴레이션의 튜플 저장 관리

릴레이션간의 관계 정립

Null이 가능 참조 하지 않을 수 있다.
```

---

### SQL 실행 순서
FROM(Relation Select) -> Where(Relation Read and where check) -> select(Projection) -> order by

우선순위는 헷갈리기 때문에 괄호로 감싸는게 알맞다

---

### 집계 함수

***여러 행으로 부터 하나의 결과 값을 반환

```
AVG
Count
MAX
MIN
SUM
STDDEV
VARIANCE
등 ...
``` 

***집계 함수 주의할 점 
1. Group by에 참여한 Column이나 Aggregate 함수만 사용 될 수 있다
2. Where 절은 Aggregation 이전 단계에 적용된다.
3. Null인 데이터는 집합 함수에 참여하지 않는다. 

Count( * )은 해당 Row의 총 개수를 Null 포함

***또 Having 절은 Aggreation 이후 filtering기능으로 적용된다.


## CASE

- CASE와 중첩 CASE문으로 조건문을 처리가능
- 주의점 : Group by나 order by를 할 때 CASE를 같이 써줘야 한다는 것



