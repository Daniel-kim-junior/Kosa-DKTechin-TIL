
## 서버에서 처리해야 하는 업무

### WAS를 직접 구현한다고 해보자

	1. 서버 TCP/IP 연결 대기, 소켓 연결
	2. HTTP 요청 메시지를 파싱해서 읽기
	3. HTTP Method를 분석
	4. Content-Type 확인
	5. POST라면 HTTP Body 내용 파싱
	6. 저장 프로세스 실행
	7. 비지니스 로직 실행
	   - 데이터베이스에 저장 요청
	8. HTTP 응답 메시지 생성 시작
	   - HTTP 시작 라인 생성
	   - Header 생성
	   - 메시지 바디에 HTML 생성에서 입력
	9. TCP/IP에 응답 전달, 소켓 종료

---

## 의미있는 작업은 7번 밖에 없다
	- 서블릿이 7번 이외의 모든 작업을 지원해준다.

---

##  HTTP 요청, 응답 흐름

- HTTP 요청시
	- WAS는 Request, Response 객체를 새로 만들어서 서블릿 객체 호출
	- 개발자는 Request 객체에서 HTTP 요청 정보를 편리하게 꺼내서 사용
	- 개발자는 Response 객체에 HTTP 응답 정보를 편리하게 입력하게 입력
	- WAS는 Response 객체에 담겨있는 내용으로 HTTP 응답 정보를 생성

WAS안에는 서블릿 컨테이너가 존재
서블릿 컨테이너는 서블릿 객체들의 생명주기를 관리
서블릿 객체는 싱글톤으로 관리

Request, Response는 클라이언트마다 다르니 요청마다 생성

---

## 서블릿 객체를 호출하는 쓰레드

다중 요청을 위해 멀티 쓰레드 지원하는 WAS

*장점 :
	동시 요청 처리 가능
	리소스(CPU, 메모리) 허용까지 가능
	하나의 쓰레드가 지연 되어도, 나머지 쓰레드는 정상 동작

*단점:
	쓰레드 생성 비용이 비싸다
	고객의 요청이 올 때마다  쓰레드를 생성하면, latency 저하
	쓰레드는 컨텍스트 스위칭 비용이 발생
	쓰레드 생성에 제한이 없다
	고객 요청이 너무 많이 오면, CPU, 메모리 임계점을 넘어버려 서버가 DIE


## 해결책 : 쓰레드 풀

- 미리 쓰레드를 만들어놓고 요청 종료시에 쓰레드 종료가 아닌 대기 상태로 재활용
	1. 생성 비용 감소
	2. 쓰레드 풀의 크기로 트래픽 크기의 한계를 설정할 수 있음 (대기열)

-쓰레드 풀이 너무 작으면 - 레이턴시 증가
-쓰레드 풀이 너무 크면 - 트래픽의 제한이 높기 때문에 서버 리소스가 커버 되지 않으면 서버가 죽어버린다.

WAS가 멀티쓰레드를 처리해줘서 고맙다...

쓰레드 풀의 적정 숫자를 성능 테스트를 통해 
적절한 스레드 풀 숫자를 위해 테스트 해야한다.
nGrinder 등...

멀티 쓰레드 환경이므로 싱글톤 객체(서블릿, 스프링 빈)는 주의해서 사용해야한다.
	지역변수 이외에는 모두 Thread Safe 하지않다.
