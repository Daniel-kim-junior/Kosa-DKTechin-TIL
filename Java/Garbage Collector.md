
# Garbage Collection(GC)

JVM에 위치해 있는 GC는 자동으로 메모리를 관리해주는 기능이다.
GC는 사용되지 않는 객체를 자동으로 인식하여, 해당 객체가 사용하는 메모리를 해제.

개발자가 메모리에 대해 신경을 덜 쓸 수 있게 도와준다.

GC는 일반적으로 Heap영역에서 동작하지만 클래스 영역에서 클래스를 로드하거나 언로드 할 때도
Young GC와 Old GC로 나누어 효율적으로 메모리를 관리하는데
그 과정은 다음과 같다.
Young GC와 Old GC는 JVM에서 수행하는 Garbage Collection(GC) 작업 중에서 메모리 영역별로 구분하여 실행하는 방식

Young GC는 Eden 영역과 Survivor 영역1, 2에서 실행되는 GC 작업을 의미. 새로 생성된 객체는 Eden 영역에 할당되며, 

### Eden 영역이 가득 차면

객체 중에서 살아남은 객체는 Survivor 영역1로 이동됩니다. 그리고 다음번 Young GC가 실행될 때, Survivor 영역1에 남아있는 객체들 중에서 살아남은 객체는 Survivor 영역2로 이동된다. 
이후, Young GC가 다시 실행될 때는 Survivor 영역1에 남아있는 객체들과 Survivor 영역2에 남아있는 객체들 중에서 살아남은 객체들을 모두 Old 영역으로 이동시킨다.

Old GC는 Old 영역에서 실행되는 GC 작업을 의미하고 Old 영역은 Young GC가 여러번 수행되어도 살아남은 객체들이 이동하게 되는 메모리 영역이기 때문에 

Young GC보다는 큰 객체들이 저장되는 공간이다.

따라서 Old GC는 Young GC보다 더 드문 간격으로 실행되며, Old 영역에서 메모리 부족이 발생하거나, Full GC를 실행해야 할 때 실행된다.

Young GC와 Old GC는 메모리 영역별로 구분하여 실행함으로써, 메모리 부족을 더욱 효율적으로 처리할 수 있으며, GC 작업의 성능을 향상시킬 수 있다. (Divide)


GC의 과정은 두가지로 나눌 수 있는데
첫번째 단계는 더 이상 사용하지 않는 객체를 식별하는 것
두번째 단계는 해당 객체가 사용하고 있던 메모리를 해제하는 것

1.  Mark and Sweep 알고리즘

Java에서 가장 기본적으로 사용되는 GC 알고리즘은 Mark and Sweep 알고리즘입니다. 이 알고리즘은 다음과 같은 과정을 거칩니다.

-   먼저, 모든 객체를 순회하면서 사용되는 객체를 표시합니다. 이 과정을 "Mark" 단계라고 합니다.
-   Mark 단계가 끝나면, 표시되지 않은 객체(사용되지 않는 객체)를 Heap에서 제거합니다. 이 과정을 "Sweep" 단계라고 합니다.

이 과정에서 GC는 메모리에서 불필요한 객체를 제거하고, 메모리를 효율적으로 관리하여 애플리케이션의 성능을 최적화합니다.

2.  압축(Compaction) 알고리즘

Mark and Sweep 알고리즘 외에도, Java에서는 압축(Compaction) 알고리즘도 사용됩니다. 이 알고리즘은 Heap에서 사용되지 않는 객체를 제거하는 대신, 사용되는 객체를 한 곳으로 모아서 메모리 공간을 확보하는 방법입니다. 이렇게 하면 GC가 빈번히 발생할 때마다 Heap 내부에 메모리 조각이 생기는 것을 방지할 수 있습니다.

압축 알고리즘은 Mark and Sweep 알고리즘에 비해 더 복잡하고 성능이 좋지 않은 경우가 있지만, Heap 내부에서 메모리 조각이 발생하는 것을 방지하므로 애플리케이션의 성능을 개선하는 데 도움을 줄 수 있습니다.

---