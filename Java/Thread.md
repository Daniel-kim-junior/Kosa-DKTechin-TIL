# Thread

- Thread는 왜 필요한가? 멀티 코어 아키텍처로 하드웨어의 진화에 따라
하드웨어를 100%로 활용할 수 없어졌다. 이를 위해 응답성과 성능을 더 높이기 위해

1. 응답성
    - 여러 요청을 병렬적으로 처리 가능한 장점
    - 구현 예) Apache Tomcat, jetty 등의 서블릿 컨테이너들
    
2. 응답성
    - 하나의 코어로도 멀티 태스킹이 일어나고 있는 착각을 구현할 수 있음
    - 그러나 진정한 의미의 병렬성은 아님 (Contect Switching이 일어나기 때문)
    - 따라서 하드웨어의 개수를 줄일 수 있고 비용 절감의 이점을 가짐

## Process Architecture

    - 메모리에 올라간 프로세스 즉 사용자가 작성한 프로그램은
    다른 프로세스들과는 격리되어 있음

    PID - 어플리케이션이 읽고 쓰기 위해 여는 파일

    Code - CPU가 연산해야하는 부분

    Heap - Appication Data

    Thread - Stack과 Instruction Point

    ** Thread는 각각의 Stack과 Instruction Pointer를 격리된 환경에서 가지고 있음
    나머지는 모두 공유한다.(File, Heap, Code)


## Thread의 경쟁
    ```
    일반적으로 코어보다 Process가 훨씬 많고 각각의 프로세스는 하나 이상의 스레드를 
    가진다.
    ```

### Context Switching
  
    - 쓰레드 하나를 계산했다가 다른 쓰레드로 계산을 이관하는 이 순간을 컨텍스트 스위치라고
  한다.

  - 동시에 많은 쓰레드를 다룰 때 효율성이 떨어지는 원인이 된다.

  너무 많은 스레드를 가동하게 되면 이 컨텍스트 스위칭 관리가 일을 처리하는
  것보다 더 커지는 '스레싱'이 일어나게 된다.

  프로세스가 리소스를 더 적게 사용하는 이유는 앞서 공부한 다른 스레드와
  공유하는 부분이 많기 때문인데

  추측하기론 캐싱되는 데이터 때문에  다른 프로세스의 스레드와 컨텍스트 스위칭 되는 것보다
  같은 프로세스 내의 스레드와 컨텍스트 스위칭 되는것이 더 효율적이라고 할 수 있을 것 같다.

### Thread의 자원

    - Thread가 만들어진다면 아무 작업도 하지 않는다 해도 메모리와 일부 커널 리소스를 사용한다.
    - 만약 실행 중이라면 CPU 연산 시간 뿐만 아니라 컨텍스트 스위칭을 최소화 하기 위한 캐시 메모리도 사용
    
### Thread 정지
    - 어플리케이션 정지를 위해
    - 오작동하는 스레드를 종료하기 위해
    - 사용 목적을 다했을때
    - 메인 스레드가 종료되었다 하더라도 한개 이상의 자식 스레드들이 작동하고 있다면 프로세스는 종료되지 않음
    - 따라서 모든 스레드를 종료하기 위한 기능이 필요함

    ```
    정지 방법 3개
    1. Demon Thread 로 설정 (Demon Thread는 main Thread가 종료되면 함께 종료된다.)
    2. Interrupt 함수를 이용
    3. 명시적 Interrupt 로직이 없다면 수행 중인 작업 (ex) 반복문) 등에 isInterrupted 메소드를
    명시하여 인터럽트를 감지하게 하자
    ```

### Thread의 join
    
여기 두개의 스레드가 있다고 가정해보자.

스레드 A는 스레드 B의 결과값을 동기적으로 참조할 때 간단하게는 스레드 A가 무한 루프를 돌며 B의 결과가    나왔는지 확인하면 되지만 이는 CPU 사이클을 굉장히 많이 사용하게 되어 역설적으로 스레드 B의 작업을 더 느리게 하는 결과를 낳을 것이다.

이 문제를 해결하려면 어떻게 해야할까?

차라리 스레드 A를 재우는 블로킹 방식을 쓰면 어떨까? (Syncronous Blocking)

이 작업을 위해 join 메소드를 사용해보자

join 메소드는 해당 스레드의 종료를 main 스레드가 기다리는 장치를 해주기 때문에 해당 스레드의 작업 완료를
보장한다. 

그렇지만 만약 어떤 하나의 스레드에 굉장히 과중한 업무가 부과되어 main 스레드가 종료 되지 않으면 어떻게 해야할까?

그러한 엣지 케이스를 방지하기 위해 우리는 스레드의 업무 시간을 제한할 필요가 있다. 해당 시간을 초과하게 되면
join 메소드를 스택에서 반환하게 된다. join에 매개변수로 시간을 넣어보자

하지만 join 메소드를 반환한다 해서 스레드가 인터럽트 되는 것은 아니다.
앞서 알아봤던 정지 방법 3개를 가지고 수동으로 인터럽트 로직을 작성해주어야 한다.


