1. SQL Table은 허용하지 않는 Identify가 있다.
    - order, user, etc... sql에 관련된 식별자는 사용해서는 안된다.
    
2. Entity 어노테이션을 붙인 친구들도 JPA의 관리대상이기 때문에
    영속성 컨텍스트에 의해 관리 된다. 즉 자동으로 생성되는 GenerateValue 등을 직접 조작해서는
    안된다!
    
3. SQL 지연 쿼리를 쓰기 때문에 transation이 종료되는 시점에 SQL쿼리가 나가게 된다
    다만 예외적으로 JPQL로 직접 쿼리를 날리는 경우나 Create 할때 ID 식별자를 SQL에게
    위임하는 경우에는 Flush 시점에 쿼리가 바로 날라가게 된다.
<<<<<<< Updated upstream
4. 양방향 연관관계일 때 외래키에만 참조값을 넣어줘도 SQL Select 시점에 JPA가 Lazy Select 해주지만
    객체 지향적 관점에서 List에도 값을 같이 넣어주는 것이 맞다    
=======
    
4. 양방향 연관관계일 때 값을 모두 넣어줘야하는 이유
    외래키를 가진 연관관계의 주인에게만 넣어줘도 SQL에 쿼리를 넣어 동작을 한다.
    하지만 1의 관계를 가진 Mapped된 객체에도 값을 넣어줘야하는 이유는
    영속성 컨텍스트의 1차캐시에 값이 있다면 그 값을 그대로 써버리기 때문에 Mapped된 1의 객체에도
    값을 넣어줘야 된다.
    그렇게 되면 1차 캐시에서 값을 그대로 참조하게 되더라도 값을 제대로 확인할 수 있게 된다.
    순수 자바 테스트에서도 그 값을 제대로 확인할 수 있기 때문에 객체지향적으로 옳다.
    
    **따라서 순수 객체 상태를 고려해 양쪽에 값을 세팅하자
    
    

    
>>>>>>> Stashed changes

    
