# JPA의 타입

### 값 타입

- String, int, Integer 등의 순수 primitive type 및 Wrapper 클래스
- Wrapper 클래스는 값 그 자체가 아닌 주소 값을 공유하기 때문에 문제가 될 수 있으나
  자바의 Wrapper클래스는 변경에 닫혀있기 때문에 안전하게 설계가능하다.

### 임베디드 타입

Period(startDate, endDate), Address(city, street, zipcode) 등등 연관 값타입을
모아서 하나의 클래스로 만들어 사용
JPA에서 사용하기 위해 설정이 필요함

- @Embeddable: 값 타입을 정의하는 곳에 표시
- @Embedded: 값 타입을 사용하는 곳에 표시
- 기본 생성자 필수

### 임베디드 타입의 장점

- 재사용
- 높은 응집도
- Period isWork()처럼 해당 값 타입만 사용하는 의미 있는 메소드를 만들 수 있음
- 임베디드 타입을 포함한 모든 값 타입은, 값 타입을 소유한 엔티티에 생명주기를 의존함

값 타입을 묶어서 클래스를 정의한다면 행위까지 정의할 수 있어서 가질 수 있는 이득이 크다

### 임베디드 타입과 테이블 매핑

- 임베디드 타입은 엔티티의 값일 뿐이다.
- 임베디드 타입을 사용하기 전과 후에 매핑하는 테이블은 같다.
- 객체와 테이블을 아주 세밀하게(find-grained) 매핑하는 것이 가능하다.
- 잘 설계한 ORM 어플리케이션은 매핑한 테이블의 수보다 클래스의 수가 더 많음

임베디드 타입 클래스 안에 엔티티형 타입의 변수를 사용하여 클래스를 설계할 수 있음
Address 안에 Member 필드 등...

### 한 Entity에 같은 임베디듵 타입 변수가 2개 존재한다면?

```
private Address homeAddress;
private Address workAddress;

컬럼명이 중복 되는 문제
```

@AttributeOverrides 속성 재정의
({
@AttributeOverride(name="변수 이름", column=@Column(name = "컬럼이름"))
})

새로 매핑해서 해결

### 임베디드 타입이 Null일때

- 전체 컬럼이 null로 세팅

### 값 타입을 나누는 이유

- 값 타입은 복잡한 객체 세상을 조금이라도 단순화하려고 만든 개념이다. 따라서 값 타입은 단순하고 안전하게 다룰 수 있어야 한다.

- 임베디드 값 타입의 경우 값 타입을 여러 엔티티에서 공유하면 위험하다.

- Side Effect 발생

- 만약 공유하고 싶은 어떤 값이 있다면 Entity로 설계하자

### 객체 타입의 한계

- 항상 값을 공유해서 사용하면 공유 참조로 인해 발생하는 부작용을 피할 수 있다.
- 문제는 임베디드 타입처럼 직접 정의한 값 타입은 자바의 기본 타입이 아니라 객체 타입이다.
- 객체 타입은 참조 값을 직접 대입하는 것을 막을 방법이 없다.

### 해결책(불변 객체)

- 객체의 타입을 수정할 수 없게 만들면 부작용을 원천 차단
- 값 타입은 불변 객체(immutable object)로 설계해야함
- 불변 객체: 생성 시점 이후 절대 값을 변경할 수 없는 객체
- 생성자로만 값을 수정하고 수정자(Setter)를 만들지 않는다
  변경에 닫혀있게

### 값 타입의 비교

- 값 타입의 필드 비교 시 같은 타입인지 비교방법
  eqals, hashCode를 재정의하여(주로 모든 필드 사용 - 왠만하면 기본으로 만들어주는것으로)
